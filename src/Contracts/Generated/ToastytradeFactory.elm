module Contracts.Generated.ToastytradeFactory exposing
    ( CreatedTrade
    , NewToastytrade
    , createdTrades
    , createdTradesDecoder
    , devFeeAddress
    , getDevFee
    , getNumToastytradeSells
    , newToastytradeDecoder
    , newToastytradeEvent
    , openToastytrade
    , tokenContract
    )

import Abi.Decode as AbiDecode exposing (abiDecode, andMap, data, toElmDecoder, topic)
import Abi.Encode as AbiEncode exposing (Encoding(..), abiEncode)
import BigInt exposing (BigInt)
import Eth.Types exposing (..)
import Eth.Utils as U
import Json.Decode as Decode exposing (Decoder, succeed)
import Json.Decode.Pipeline exposing (custom)



{-

   This file was generated by https://github.com/cmditch/elm-ethereum-generator

-}


{-| "createdTrades(uint256)" function
-}
type alias CreatedTrade =
    { address_ : Address
    , blocknum : BigInt
    }


createdTrades : Address -> BigInt -> Call CreatedTrade
createdTrades contractAddress a =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "createdTrades(uint256)" [ AbiEncode.uint a ]
    , nonce = Nothing
    , decoder = createdTradesDecoder
    }


createdTradesDecoder : Decoder CreatedTrade
createdTradesDecoder =
    abiDecode CreatedTrade
        |> andMap AbiDecode.address
        |> andMap AbiDecode.uint
        |> toElmDecoder


{-| "devFeeAddress()" function
-}
devFeeAddress : Address -> Call Address
devFeeAddress contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "devFeeAddress()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.address
    }


{-| "getDevFee(uint256)" function
-}
getDevFee : Address -> BigInt -> Call BigInt
getDevFee contractAddress tradeAmount =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "getDevFee(uint256)" [ AbiEncode.uint tradeAmount ]
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "getNumToastytradeSells()" function
-}
getNumToastytradeSells : Address -> Call BigInt
getNumToastytradeSells contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "getNumToastytradeSells()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "openToastytrade(address,bool,uint256[6],string,string,string)" function
-}
openToastytrade : Address -> Address -> Bool -> BigInt -> BigInt -> BigInt -> BigInt -> BigInt -> BigInt -> String -> String -> String -> Call Address
openToastytrade contractAddress initiator initiatorIsBuyer tokenAmount buyerDeposit pokeReward autorecallInterval autoabortInterval autoreleaseInterval totalPrice fiatTransferMethods commPubkey =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data =
        Just <|
            AbiEncode.functionCall
                "openToastytrade(address,bool,uint256[6],string,string,string)"
                [ AbiEncode.address initiator
                , AbiEncode.bool initiatorIsBuyer
                , AbiEncode.uint tokenAmount
                , AbiEncode.uint buyerDeposit
                , AbiEncode.uint pokeReward
                , AbiEncode.uint autorecallInterval
                , AbiEncode.uint autoabortInterval
                , AbiEncode.uint autoreleaseInterval
                , AbiEncode.string totalPrice
                , AbiEncode.string fiatTransferMethods
                , AbiEncode.string commPubkey
                ]
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.address
    }


{-| "tokenContract()" function
-}
tokenContract : Address -> Call Address
tokenContract contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "tokenContract()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.address
    }


{-| "NewToastytrade(uint256,address,bool)" event
-}
type alias NewToastytrade =
    { id : BigInt
    , toastytradeAddress : Address
    , initiatorIsPayer : Bool
    }


newToastytradeEvent : Address -> Maybe Bool -> LogFilter
newToastytradeEvent contractAddress initiatorIsPayer =
    { fromBlock = LatestBlock
    , toBlock = LatestBlock
    , address = contractAddress
    , topics =
        [ Just <| U.keccak256 "NewToastytrade(uint256,address,bool)"
        , Maybe.map (abiEncode << AbiEncode.bool) initiatorIsPayer
        ]
    }


newToastytradeDecoder : Decoder NewToastytrade
newToastytradeDecoder =
    succeed NewToastytrade
        |> custom (data 0 AbiDecode.uint)
        |> custom (data 1 AbiDecode.address)
        |> custom (topic 1 AbiDecode.bool)
