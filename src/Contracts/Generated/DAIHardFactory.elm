module Contracts.Generated.DAIHardFactory exposing
    ( CreatedTrade
    , GetExtraFees
    , NewTrade
    , createdTrades
    , createdTradesDecoder
    , daiContract
    , devFeeAddress
    , getBuyerDeposit
    , getDevFee
    , getExtraFees
    , getNumTrades
    , newTradeDecoder
    , newTradeEvent
    , openDAIHardTrade
    )

import Abi.Decode as AbiDecode exposing (abiDecode, andMap, data, toElmDecoder, topic)
import Abi.Encode as AbiEncode exposing (Encoding(..), abiEncode)
import BigInt exposing (BigInt)
import Eth.Types exposing (..)
import Eth.Utils as U
import Json.Decode as Decode exposing (Decoder, succeed)
import Json.Decode.Pipeline exposing (custom)



{-

   This file was generated by https://github.com/cmditch/elm-ethereum-generator

-}


{-| "createdTrades(uint256)" function
-}
type alias CreatedTrade =
    { address_ : Address
    , blocknum : BigInt
    }


createdTrades : Address -> BigInt -> Call CreatedTrade
createdTrades contractAddress a =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "createdTrades(uint256)" [ AbiEncode.uint a ]
    , nonce = Nothing
    , decoder = createdTradesDecoder
    }


createdTradesDecoder : Decoder CreatedTrade
createdTradesDecoder =
    abiDecode CreatedTrade
        |> andMap AbiDecode.address
        |> andMap AbiDecode.uint
        |> toElmDecoder


{-| "daiContract()" function
-}
daiContract : Address -> Call Address
daiContract contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "daiContract()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.address
    }


{-| "devFeeAddress()" function
-}
devFeeAddress : Address -> Call Address
devFeeAddress contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "devFeeAddress()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.address
    }


{-| "getBuyerDeposit(uint256)" function
-}
getBuyerDeposit : Address -> BigInt -> Call BigInt
getBuyerDeposit contractAddress tradeAmount =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "getBuyerDeposit(uint256)" [ AbiEncode.uint tradeAmount ]
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "getDevFee(uint256)" function
-}
getDevFee : Address -> BigInt -> Call BigInt
getDevFee contractAddress tradeAmount =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "getDevFee(uint256)" [ AbiEncode.uint tradeAmount ]
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "getExtraFees(uint256)" function
-}
type alias GetExtraFees =
    { buyerDeposit : BigInt
    , devFee : BigInt
    }


getExtraFees : Address -> BigInt -> Call GetExtraFees
getExtraFees contractAddress tradeAmount =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "getExtraFees(uint256)" [ AbiEncode.uint tradeAmount ]
    , nonce = Nothing
    , decoder = getExtraFeesDecoder
    }


getExtraFeesDecoder : Decoder GetExtraFees
getExtraFeesDecoder =
    abiDecode GetExtraFees
        |> andMap AbiDecode.uint
        |> andMap AbiDecode.uint
        |> toElmDecoder


{-| "getNumTrades()" function
-}
getNumTrades : Address -> Call BigInt
getNumTrades contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "getNumTrades()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "openDAIHardTrade(address,bool,uint256[5],string,string,string)" function
-}
openDAIHardTrade : Address -> Address -> Bool -> BigInt -> BigInt -> BigInt -> BigInt -> BigInt -> String -> String -> String -> Call Address
openDAIHardTrade contractAddress initiator initiatorIsBuyer daiAmount pokeReward autorecallInterval autoabortInterval autoreleaseInterval totalPrice fiatTransferMethods commPubkey =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data =
        Just <|
            AbiEncode.functionCall
                "openDAIHardTrade(address,bool,uint256[5],string,string,string)"
                [ AbiEncode.address initiator
                , AbiEncode.bool initiatorIsBuyer
                , AbiEncode.uint daiAmount
                , AbiEncode.uint pokeReward
                , AbiEncode.uint autorecallInterval
                , AbiEncode.uint autoabortInterval
                , AbiEncode.uint autoreleaseInterval
                , AbiEncode.string totalPrice
                , AbiEncode.string fiatTransferMethods
                , AbiEncode.string commPubkey
                ]
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.address
    }


{-| "NewTrade(uint256,address,bool)" event
-}
type alias NewTrade =
    { id : BigInt
    , tradeAddress : Address
    , initiatorIsPayer : Bool
    }


newTradeEvent : Address -> Maybe Bool -> LogFilter
newTradeEvent contractAddress initiatorIsPayer =
    { fromBlock = LatestBlock
    , toBlock = LatestBlock
    , address = contractAddress
    , topics =
        [ Just <| U.keccak256 "NewTrade(uint256,address,bool)"
        , Maybe.map (abiEncode << AbiEncode.bool) initiatorIsPayer
        ]
    }


newTradeDecoder : Decoder NewTrade
newTradeDecoder =
    succeed NewTrade
        |> custom (data 0 AbiDecode.uint)
        |> custom (data 1 AbiDecode.address)
        |> custom (topic 1 AbiDecode.bool)
