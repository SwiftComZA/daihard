module Contracts.SugarSale.Generated.BucketSale exposing
    ( Buy
    , Drained
    , Entered
    , Exited
    , blocksPerBucket
    , bucketSupply
    , buckets
    , buys
    , buysDecoder
    , currentBucket
    , drain
    , drainedDecoder
    , drainedEvent
    , enter
    , enteredDecoder
    , enteredEvent
    , exit
    , exitedDecoder
    , exitedEvent
    , min
    , owner
    , referredTotal
    , referrerRewardPerc
    , saleEndBlock
    , saleStartBlock
    , setSaleEndBlock
    , setSaleStartBlock
    , startSaleNow
    , tokenOnSale
    , tokenSoldFor
    )

import Abi.Decode as AbiDecode exposing (abiDecode, andMap, data, toElmDecoder, topic)
import Abi.Encode as AbiEncode exposing (Encoding(..), abiEncode)
import BigInt exposing (BigInt)
import Eth.Types exposing (..)
import Eth.Utils as U
import Json.Decode as Decode exposing (Decoder, succeed)
import Json.Decode.Pipeline exposing (custom)



{-

   This file was generated by https://github.com/cmditch/elm-ethereum-generator

-}


{-| "blocksPerBucket()" function
-}
blocksPerBucket : Address -> Call BigInt
blocksPerBucket contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "blocksPerBucket()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "bucketSupply()" function
-}
bucketSupply : Address -> Call BigInt
bucketSupply contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "bucketSupply()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "buckets(uint256)" function
-}
buckets : Address -> BigInt -> Call BigInt
buckets contractAddress a =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "buckets(uint256)" [ AbiEncode.uint a ]
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "buys(uint256,address)" function
-}
type alias Buy =
    { valueEntered : BigInt
    , tokensDisbursed : BigInt
    , referralAddress : Address
    }


buys : Address -> BigInt -> Address -> Call Buy
buys contractAddress a b =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "buys(uint256,address)" [ AbiEncode.uint a, AbiEncode.address b ]
    , nonce = Nothing
    , decoder = buysDecoder
    }


buysDecoder : Decoder Buy
buysDecoder =
    abiDecode Buy
        |> andMap AbiDecode.uint
        |> andMap AbiDecode.uint
        |> andMap AbiDecode.address
        |> toElmDecoder


{-| "currentBucket()" function
-}
currentBucket : Address -> Call BigInt
currentBucket contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "currentBucket()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "drain(address)" function
-}
drain : Address -> Address -> Call ()
drain contractAddress target =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "drain(address)" [ AbiEncode.address target ]
    , nonce = Nothing
    , decoder = Decode.succeed ()
    }


{-| "enter(address,uint256,address)" function
-}
enter : Address -> Address -> BigInt -> Address -> Call ()
enter contractAddress buyer amount referralAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "enter(address,uint256,address)" [ AbiEncode.address buyer, AbiEncode.uint amount, AbiEncode.address referralAddress ]
    , nonce = Nothing
    , decoder = Decode.succeed ()
    }


{-| "exit(address,uint256)" function
-}
exit : Address -> Address -> BigInt -> Call ()
exit contractAddress buyer bucketID =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "exit(address,uint256)" [ AbiEncode.address buyer, AbiEncode.uint bucketID ]
    , nonce = Nothing
    , decoder = Decode.succeed ()
    }


{-| "min(uint256,uint256)" function
-}
min : Address -> BigInt -> BigInt -> Call BigInt
min contractAddress a b =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "min(uint256,uint256)" [ AbiEncode.uint a, AbiEncode.uint b ]
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "owner()" function
-}
owner : Address -> Call Address
owner contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "owner()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.address
    }


{-| "referredTotal(address)" function
-}
referredTotal : Address -> Address -> Call BigInt
referredTotal contractAddress a =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "referredTotal(address)" [ AbiEncode.address a ]
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "referrerRewardPerc(address)" function
-}
referrerRewardPerc : Address -> Address -> Call BigInt
referrerRewardPerc contractAddress referralAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "referrerRewardPerc(address)" [ AbiEncode.address referralAddress ]
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "saleEndBlock()" function
-}
saleEndBlock : Address -> Call BigInt
saleEndBlock contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "saleEndBlock()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "saleStartBlock()" function
-}
saleStartBlock : Address -> Call BigInt
saleStartBlock contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "saleStartBlock()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.uint
    }


{-| "setSaleEndBlock(uint256)" function
-}
setSaleEndBlock : Address -> BigInt -> Call ()
setSaleEndBlock contractAddress endBlock =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "setSaleEndBlock(uint256)" [ AbiEncode.uint endBlock ]
    , nonce = Nothing
    , decoder = Decode.succeed ()
    }


{-| "setSaleStartBlock(uint256)" function
-}
setSaleStartBlock : Address -> BigInt -> Call ()
setSaleStartBlock contractAddress startBlock =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "setSaleStartBlock(uint256)" [ AbiEncode.uint startBlock ]
    , nonce = Nothing
    , decoder = Decode.succeed ()
    }


{-| "startSaleNow()" function
-}
startSaleNow : Address -> Call ()
startSaleNow contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "startSaleNow()" []
    , nonce = Nothing
    , decoder = Decode.succeed ()
    }


{-| "tokenOnSale()" function
-}
tokenOnSale : Address -> Call Address
tokenOnSale contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "tokenOnSale()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.address
    }


{-| "tokenSoldFor()" function
-}
tokenSoldFor : Address -> Call Address
tokenSoldFor contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| AbiEncode.functionCall "tokenSoldFor()" []
    , nonce = Nothing
    , decoder = toElmDecoder AbiDecode.address
    }


{-| "Drained(address,uint256)" event
-}
type alias Drained =
    { target : Address
    , amount : BigInt
    }


drainedEvent : Address -> Maybe Address -> LogFilter
drainedEvent contractAddress target =
    { fromBlock = LatestBlock
    , toBlock = LatestBlock
    , address = contractAddress
    , topics =
        [ Just <| U.keccak256 "Drained(address,uint256)"
        , Maybe.map (abiEncode << AbiEncode.address) target
        ]
    }


drainedDecoder : Decoder Drained
drainedDecoder =
    succeed Drained
        |> custom (topic 1 AbiDecode.address)
        |> custom (data 0 AbiDecode.uint)


{-| "Entered(address,uint256,uint256)" event
-}
type alias Entered =
    { buyer : Address
    , bucket : BigInt
    , amount : BigInt
    }


enteredEvent : Address -> Maybe Address -> LogFilter
enteredEvent contractAddress buyer =
    { fromBlock = LatestBlock
    , toBlock = LatestBlock
    , address = contractAddress
    , topics =
        [ Just <| U.keccak256 "Entered(address,uint256,uint256)"
        , Maybe.map (abiEncode << AbiEncode.address) buyer
        ]
    }


enteredDecoder : Decoder Entered
enteredDecoder =
    succeed Entered
        |> custom (topic 1 AbiDecode.address)
        |> custom (data 0 AbiDecode.uint)
        |> custom (data 1 AbiDecode.uint)


{-| "Exited(address,uint256,uint256)" event
-}
type alias Exited =
    { buyer : Address
    , bucket : BigInt
    , amount : BigInt
    }


exitedEvent : Address -> Maybe Address -> LogFilter
exitedEvent contractAddress buyer =
    { fromBlock = LatestBlock
    , toBlock = LatestBlock
    , address = contractAddress
    , topics =
        [ Just <| U.keccak256 "Exited(address,uint256,uint256)"
        , Maybe.map (abiEncode << AbiEncode.address) buyer
        ]
    }


exitedDecoder : Decoder Exited
exitedDecoder =
    succeed Exited
        |> custom (topic 1 AbiDecode.address)
        |> custom (data 0 AbiDecode.uint)
        |> custom (data 1 AbiDecode.uint)
